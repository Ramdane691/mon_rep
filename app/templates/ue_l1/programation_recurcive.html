{%extends "base.html" %}
{% block main_content %}

<h2>UE L1 - Programmation récursive & Scheme</h2>

<section>
    <h3 class="toggle">Qu'est-ce que la récursivité ?</h3>
    <div class="content hidden">
        <p>
            Une fonction est récursive si elle s'appelle elle-même dans sa définition. En programmation fonctionnelle comme en Scheme, la récursivité remplace souvent les boucles.
        </p>
        <p>
            Une fonction récursive se compose généralement :
        </p>
        <ul>
            <li><strong>D’un cas de base</strong> : condition d’arrêt qui retourne une valeur sans appel récursif</li>
            <li><strong>D’un appel récursif</strong> : la fonction se rappelle sur une version "réduite" du problème</li>
        </ul>
    </div>
</section>

<section>
    <h3 class="toggle">Manipulation de listes</h3>
    <div class="content hidden">
        <p>
            Scheme est un langage fonctionnel qui travaille beaucoup avec les listes.
            Voici quelques fonctions fondamentales :
        </p>
        <ul>
            <li><code>null?</code> → teste si une liste est vide</li>
            <li><code>car</code> → récupère le premier élément</li>
            <li><code>cdr</code> → récupère le reste de la liste</li>
            <li><code>cons</code> → ajoute un élément en tête de liste</li>
        </ul>

        <p>Exemple : additionner tous les éléments d’une liste :</p>
        <pre><code>(define (somme lst)
  (if (null? lst)
      0
      (+ (car lst) (somme (cdr lst)))))</code></pre>
    </div>
</section>

<section>
    <h3 class="toggle">Calcul descendant vs remontant</h3>
    <div class="content hidden">
        <p>
            En récursivité, on distingue :
        </p>
        <ul>
            <li><strong>Calcul descendant</strong> : les calculs s'accumulent pendant la descente, puis sont évalués à la fin (ex : <code>(* n (fact (- n 1)))</code>)</li>
            <li><strong>Calcul remontant (accumulateur)</strong> : la valeur se construit au fur et à mesure, utile pour optimiser la mémoire (tail-recursive)</li>
        </ul>

        <p>Exemple descendant (factorielle) :</p>
        <pre><code>(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))</code></pre>

        <p>Exemple remontant (avec accumulateur) :</p>
        <pre><code>(define (fact-acc n acc)
  (if (= n 0)
      acc
      (fact-acc (- n 1) (* acc n))))

(define (fact-tail n)
  (fact-acc n 1))</code></pre>
    </div>
</section>

<section>
    <h3 class="toggle">Tri récursif : tri par insertion</h3>
    <div class="content hidden">
        <p>Le tri par insertion récursif insère le premier élément au bon endroit dans une liste triée :</p>

        <pre><code>(define (inserer x lst)
  (cond
    ((null? lst) (list x))
    ((<= x (car lst)) (cons x lst))
    (else (cons (car lst) (inserer x (cdr lst))))))

(define (tri-insertion lst)
  (if (null? lst)
      '()
      (inserer (car lst) (tri-insertion (cdr lst)))))</code></pre>
    </div>
</section>

<section>
    <h3 class="toggle">Manipulation d’arbres</h3>
    <div class="content hidden">
        <p>
            Un arbre binaire est représenté en Scheme par une liste de 3 éléments :
            <code>(valeur sous-arbre-gauche sous-arbre-droit)</code>
        </p>
        <p>Exemple d’arbre :</p>
        <pre><code>(define arbre '(5 (3 () ()) (8 (6 () ()) ())))</code></pre>

        <p>
            Parcours **infixe** (gauche → racine → droite) :
        </p>
        <pre><code>(define (parcours-infixe arbre)
  (if (null? arbre)
      '()
      (append (parcours-infixe (cadr arbre))
              (list (car arbre))
              (parcours-infixe (caddr arbre)))))</code></pre>

        <p>
            Tu peux aussi faire des parcours préfixes (racine d’abord) ou suffixes (feuilles d’abord).
        </p>
    </div>
</section>

<section>
    <h3 class="toggle">Exercice : somme d’une liste</h3>
    <div class="content hidden">
        <p>
            Écris une fonction Scheme <code>somme</code> qui prend une liste de nombres et retourne leur somme.
        </p>
        <pre><code>; Résultat attendu :
(somme '(1 2 3)) ; → 6</code></pre>

        <input type="text" id="rep-scheme" placeholder="(define (somme lst) ...)">
        <button onclick="verifScheme()">Vérifier</button>
        <p id="rep-scheme-resultat"></p>
    </div>
</section>


{%endblock%}